# 質疑コーナー

> JavaScriptプログラム自身を非同期にするような機能がコア言語に含まれていない、がイメージできませんでした。
> Promiseなどを用いずに、それぞれのプログラムの式などをサーバ・クライアントで非同期に実行するような仕様は言語にはない、のような意味？

> 「皮肉なことに、JavaScript には非同期な処理を行うために強力な機能が備わっていますが、
> JavaScript プログラム自身を非同期にするような機能はコア言語には含まれていません。このため、Promiseやasync、await、for/awaitを説明するために、まずクライアントサイドJavaScriptとサーバサイドJavaScript に寄り道します。」
> ブラウザやNode等の実行環境がもつ機能→タイマー、イベント、ネットワークイベント、
> Nodeのコールバックイベントコア言語に含まれる機能→Promise/async/awaitということ？

非同期の処理をするには、fetchとか実行環境が用意してくれている環境を使わないとそもそもそういう処理は走らない

Promiseなどがコア言語に含まれるかはグレー

> なお、addEventListener()のほうが柔軟に処理ができます。複数のイベントハンドラを登録できるからです。
> とありますが、addEventListener() の中の処理でも各種イベント名のプロパティが存在していて、コールバック関数を登録する処理をしているのでしょうか？
> そうであれば、どのようにして同一のイベントに対して複数のイベントハンドラを登録するのでしょうか？

イベントごとにリストを持って管理している

> Nodeのfs.readFile()関数には、第1引数として、2つのパラメータを持つコールバックを指定します。
> とありますが、第一引数には string 型を指定しているように見えます。第3引数に2つのパラメータを持つコールバックを指定している、の間違いじゃないでしょうか？

誤植です

> // 低レベルのネットワークエラーのためにイベントハンドラを登録する。
> request.on("error", (err) => {
> callback(err, null);
> });
> 「低レベル」のネットワークエラーはどういう意味ですか

レスポンスの処理ではなくgetで発生するエラー、レスポンスが来てるか来てないか、ここで処理するエラーが500すら返ってきていない。OSI参照モデルの下の方という意味。

> then()を呼び出したときに、非同期の計算処理が完了している場合 でも、非同期に呼び出されます。
> とありますが、この「非同期の計算処理」とは Promise を返す関数の処理の計算処理のことでしょうか？

(省略)

> 「pは値vで解決されます」「p は解決されますが、まだ満たされません」
> この場合は、pはpendingになりますか https://qiita.com/uhyo/items/a9f6e70f43287cc0f52e#fulfilled-rejected-settled の説明を読んで、「ポイントは、Promiseというのは自身の結果を他のPromiseに委譲することができるという点です。」ここでは、pの結果がvに依存します。つまり、pの結果がvに委譲するということですか

pendingだし、委譲の関係もあっている

> 「これがPromiseが『解決された』状態の意味するところです」「pが『解決された』の意味するところは、pの結果はPromise vに何が起きるかに完全に依存する、という意味です」　という表現が分かりにくく感じました。
>
> あくまで「返り値vがPromiseである場合」の話をしているのに、一文だけ読むと「解決された」状態すべてについての説明と捉えられかねないからです。　「これがPromiseが『解決されたが、まだ満たされていない』状態の意味～」と書いた方が分かりやすくないでしょうか？
> 個人的にはECMAScriptそのまま読んだ方が簡明で腑に落ちました。
> ECMAScript 25.6 Promise Objects(https://262.ecma-international.org/9.0/index.html#sec-promise-objects)に以下のように書かれていました。
> A promise is resolved if it is settled or if it has been “locked in” to match the state of another promise.
> 後半の「他のPromiseの状態に“ロックされている”場合」というのが教科書該当ページで扱っている状況で、それ以外にも単に「完了した(settled)」場合も「解決された(resolved)」と言えることが明記されています。また、
> A promise is said to be settled if it is not pending, i.e. if it is either fulfilled or rejected.
>
> 「完了した(settled)」の定義は「満たされた(fullfilled)」か「失敗した(rejected)」であることも明記されていました。

あっている

> 非同期処理、例えばfetch()のタイムアウトはどのように実装するのが一般的でしょうか

abortが使えます。

> コールバックが正常な場合、catch()のコールバックは呼び出されないとありますが、メソッドチェーンとして見ると途中のメソッドがスキップできる方法が分かりませんでした。Promiseの実装で、見かけ上呼び出していないようにしているのでしょうか。

なぜcatchはエラーがスローされた時だけ実行されないのか？と言う質問。

> queryDatabase() は caｔch でリトライしていますが、このコードでリトライを行って、そのリトライ後もエラーが出た場合、再度リトライされ、無限にリトライが続いてしまうと思うのですが、あっていますか？
> そうだとすると問題になりませんか？

無限リトライになるかどうかでいうとなる。製品では上限も組み込みましょう。

> Promise.all()に入力配列に、Promiseオブジェクトでない値を含めることができますが、どういうシチュエーションで使うのでしょうか

> Response.json()のjsonはなぜpromiseで返される仕様なのか、違和感がありました。時間がかかるかもしれないから？

レスポンスを全部受信してからやるのは大変なので、promiseになっている

> 「既存のPromiseベースのAPI」というのはfs/promisesのようなものでしょうか？具体的な例があれば教えて欲しいです。（解釈が誤っているかもしれません）

yes, fetchなどPromiseを返すAPI

> 例13-1でreject()の後にresponse.resume();とありますが、Errorを発生させた後にここに戻ってくる、で合っていますでしょうか

大体yes, rejectはただの関数なのでthrowとは違う

> 「プログラムをプロックする」のプロックとは何でしょうか？(誤字？)

誤字です

> 「awaitキーワードはプログラムをブロックせず」とありますが、awaitはPromiseを受け取ったらPromiseの非同期処理が完了するまでは次の処理に進まない（見かけ上同期のように振る舞う）と理解しています。これは「プログラムをブロックせず」という言葉と相反するように感じました。例えば下記のような処理をした場合は、completedが表示されるまでfooは表示されませんので、awaitを使わない非同期処理と比べるとプログラムをブロックしているように思ったため。
> ここで言っていることはPromiseの非同期処理は進めるからブロックはしていないという意味でしょうか。

基本javaでファイル読み込みをするとブロッキングのAPIなので完全にブロックされる

> async/awaitを使用することによるデメリットもしくは、そもそも使えないということがどういった場面で起こるかイメージがついていません。
> 基本的にはPromiseベースでの記述をasync/awaitを用いて書くことで、一見同期的なコードに見え可読性が上がる。ので基本的に使えばよいが、
> asyncの宣言がある関数中で使える記述方法のため、それに頼りすぎるのは良くない。という認識でいます。
> ここで書かれている「しかし、このコードが動くのは、別のasync関数の中だけ、～トップレベルのコードや～使えません。」と念押しされていることから、
> 非同期処理がトップレベルのコード内によく出てくるのかなと思っているのですが、そうなのでしょうか？
