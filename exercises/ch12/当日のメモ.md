# 質疑コーナー

> 「部分的に使用済み」の意味が分かりませんでした。途中から、のような感じでしょうか？

大体あっている。iterが1を使ったから1がなくなっているの部分的に残っているという認識であっています。

> [Symbol.iterator]()がいまいちわかりません。
> Symbol.iteratorは、反復可能にするためのSymbolのメソッドの認識です。
> 文中に「Symbol.iteratorという～メソッドを実装する必要があります」とあるため、メソッド実装時は
> Symbol.iterator() {hogehoge}
> のように書くのかと思っていましたが、唐突に[Symbol.iterator](){hogehoge}の形になっているように感じます。なぜ [ ]()の形になるのでしょうか？そういうものでしょうか？

これは計算プロパティ、何かの値を計算してこれをプロパティ名にするときにルールで括弧の中に計算して変数にする。

> 「(yield\*を使うと再帰的ジェネレータを定義できるが、）この機能を使えば再帰的に定義された木構造に対して、非再帰的な反復をおこなうことができる」がイメージしづらいです。

詳しい説明は一回パス、演習問題で再度解説。再帰関数ではないが、再帰的ジェネレータを使っている。

> 「next()の最初の呼び出しはジェネレータを起動しますが、その呼び出しに渡された値はジェネレータ側ではアクセスできません。」とありますが、アクセスできないのはなぜですか？

よく使うのかで言えば、あまり使ったことがない。が、最近はChatGPTを簡単に使えるvercel AIではジェネレータを使って使う前提のライブラリが提供されている。テキストの程度ならたかりなさんは許せる。

> ページの一番上の例についてです。確かに説明としてはわかりますが、追うのが辛くてデバッグもしんどい気がします。ジェネレータは便利なところはありますが、複雑なジェネレータは頻繁に利用されるものですか？

ジェネレータの挙動確認の演習問題はnextが呼ばれるまで動かないのは確認できたが、どこで受け取ったのかわからないから、そういう仕様になったのではないか。yieldが呼ばれるまでは引数を見れないので、最初の引数は捨てられる。

> ジェネレータ関数の一般的な話です。ジェネレータ関数の状態?初期化は再度ジェネレータ関数を呼べばできると思います。return()やthrow()はありますが、初期化のためのメソッドがないことから、あえて初期化をすることはないでしょうか？

新しいものをつくてば良いのではないか、と思った。
