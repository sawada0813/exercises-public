{"version":3,"file":"main.js","mappings":"mBACO,SAASA,EAAWC,EAAMC,EAAMC,EAAMC,EAAKC,GAChD,IAAK,IAAIC,EAAM,EAAGA,EAAMJ,EAAMI,IAC5B,IAAK,IAAIC,EAAM,EAAGA,EAAMJ,EAAMI,IAAO,CACnC,MAAMC,EAAOP,EAAKK,GAAKC,GACvBH,EAAIK,YACJL,EAAIM,KAAKH,EAAMF,EAAYC,EAAMD,EAAYA,EAAYA,GACzDD,EAAIO,UAAYH,EAAO,QAAU,QACjCJ,EAAIQ,OACJR,EAAIS,QACN,CAEJ,CCRA,MAKMC,EAASC,SAASC,cAAc,WAChCZ,EAAMU,EAAOG,WAAW,MACxBC,EAAcH,SAASC,cAAc,UACrCG,EAAcJ,SAASC,cAAc,UAE3CF,EAAOM,MAAQlB,IACfY,EAAOO,OAASlB,IAGhB,IAAImB,EAAc,KAGlB,MAAMC,EAAQ,IAAIC,MAAM,gCAGxB,IAAIvB,EAAO,IAAIwB,MApBF,IAqBVb,KAAK,MACLc,KAAI,IACH,IAAID,MAtBK,IAsBOb,KAAK,MAAMc,KAAI,MAAQC,KAAKC,MAAsB,EAAhBD,KAAKE,cAmB3D,SAASC,IACP7B,EC9CK,SAAoBA,GAEzB,MAAM8B,EAAW9B,EAAKyB,KAAKM,GAAQ,IAAIA,KAOvC,IAAK,IAAI1B,EAAM,EAAGA,EDqCMJ,GCrCMI,IAC5B,IAAK,IAAIC,EAAM,EAAGA,EDNT,GCMqBA,IAAO,CAEnC,IAAI0B,EAAQ,EACZ,IAAK,IAAIC,GAAK,EAAGA,GAAK,EAAGA,IACvB,IAAK,IAAIC,GAAK,EAAGA,GAAK,EAAGA,IACnB7B,EAAM4B,EAAI,GAAK3B,EAAM4B,EAAI,GAAY,IAAND,GAAiB,IAANC,IACb,IAA7BlC,EAAKK,EAAM4B,KAAK3B,EAAM4B,IACxBF,IAMN,IAAIG,GAAU,EACQ,GAAlBnC,EAAKK,GAAKC,IAA0B,GAAT0B,EAC7BG,GAAU,EACiB,GAAlBnC,EAAKK,GAAKC,KACf0B,EAAQ,GAAK,EAAIA,EACnBG,GAAU,EACS,IAAVH,GAAyB,IAAVA,IACxBG,GAAU,IAGdL,EAASzB,GAAKC,GAAO6B,CACvB,CAEF,OAAOL,CACT,CDSSM,CAAWpC,GAClBD,EAAWC,EA5CA,GACA,GA2CkBG,EAzCZ,IA0CjBkB,EAAcgB,sBAAsBR,EACtC,CAlBAhB,EAAOyB,iBAAiB,SAAS,SAAUC,GACzC,MAAM9B,EAAOI,EAAO2B,wBACdC,EAAWF,EAAIG,QAAUjC,EAAKkC,KAA9BF,EAAuCF,EAAIK,QAAUnC,EAAKoC,IAE1DxC,EAAMqB,KAAKC,MAAMc,EA7BN,IA8BXnC,EAAMoB,KAAKC,MAAMc,EA9BN,IA+BjBzC,EAAKK,GAAKC,IAAQN,EAAKK,GAAKC,GAC5BgB,EAAMwB,YAAYC,OAClBhD,EAAWC,EApCA,GAqCb,IAWAiB,EAAYqB,iBAAiB,SAAS,KAEhCjB,GAGJQ,GAAQ,IAGVX,EAAYoB,iBAAiB,SAAS,KAE/BjB,IAGL2B,qBAAqB3B,GACrBA,EAAc,KAAI,IAGpBtB,EAAWC,EAjEE,GACA,GAgEgBG,EA9DV,G","sources":["webpack://ex06/./src/renderGrid.js","webpack://ex06/./src/index.js","webpack://ex06/./src/updateGrid.js"],"sourcesContent":["// grid を canvas に描画する\nexport function renderGrid(grid, ROWS, COLS, ctx, RESOLUTION) {\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      const cell = grid[row][col]\n      ctx.beginPath()\n      ctx.rect(col * RESOLUTION, row * RESOLUTION, RESOLUTION, RESOLUTION)\n      ctx.fillStyle = cell ? 'black' : 'white'\n      ctx.fill()\n      ctx.stroke()\n    }\n  }\n}\n","import { updateGrid } from './updateGrid.js'\nimport { renderGrid } from \"./renderGrid.js\";\n\n// 50 x 50 の盤面とする\nconst ROWS = 50;\nconst COLS = 50;\n// 1セルのサイズ\nconst RESOLUTION = 10;\n\nconst canvas = document.querySelector(\"#screen\");\nconst ctx = canvas.getContext(\"2d\");\nconst startButton = document.querySelector(\"#start\");\nconst pauseButton = document.querySelector(\"#pause\");\n\ncanvas.width = ROWS * RESOLUTION;\ncanvas.height = COLS * RESOLUTION;\n\n// https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame が返す ID\nlet animationId = null;\n\n// NOTE: download from https://soundeffect-lab.info/sound/button/mp3/decision1.mp3\nconst sound = new Audio(\"/ch17/ex06/src/decision1.mp3\");\n\n// ライフゲームのセル (true or false) をランダムに初期化する\nlet grid = new Array(ROWS)\n  .fill(null)\n  .map(() =>\n    new Array(COLS).fill(null).map(() => !!Math.floor(Math.random() * 2)),\n  );\n\n\n// canvas がクリックされたときの処理 (セルの値を反転する)\ncanvas.addEventListener(\"click\", function (evt) {\n  const rect = canvas.getBoundingClientRect();\n  const pos = { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n\n  const row = Math.floor(pos.y / RESOLUTION);\n  const col = Math.floor(pos.x / RESOLUTION);\n  grid[row][col] = !grid[row][col];\n  sound.cloneNode().play();\n  renderGrid(grid, ROWS)\n});\n\n// requestAnimationFrame によって一定間隔で更新・描画を行う\n// NOTE: リフレッシュレートの高い画面では速く実行される (これを防ぐ場合は下記の例を参照)\n// https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame\nfunction update() {\n  grid = updateGrid(grid, ROWS, COLS)\n  renderGrid(grid, ROWS, COLS, ctx, RESOLUTION)\n  animationId = requestAnimationFrame(update);\n}\n\nstartButton.addEventListener(\"click\", () => {\n  // 既にアニメーションが動いている場合は何もしない\n  if (animationId) {\n    return;\n  }\n  update();\n});\n\npauseButton.addEventListener(\"click\", () => {\n  // アニメーションが停止している場合は何もしない\n  if (!animationId) {\n    return;\n  }\n  cancelAnimationFrame(animationId);\n  animationId = null;\n});\n\nrenderGrid(grid, ROWS, COLS, ctx, RESOLUTION)\n","// Life Game のルールに従ってセルを更新する\nexport function updateGrid(grid, ROWS, COLS) {\n  // 新しいグリッドを作成\n  const nextGrid = grid.map((arr) => [...arr])\n\n  // 1. 近傍の生存セル数が2個未満の場合、そのセルは死ぬ\n  // 2. 近傍の生存せるが2or3個の場合、そのセルは生き続ける\n  // 3. 近傍の生存セルが3以上の場合、そのセルは死ぬ\n  // 4. 近傍の生存セルが３つの生存セルの場合、その死んだ細胞は生き返る\n\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      // 周囲のセルの生存数を数えて nextGrid[row][col] に true or false を設定する (実装してね)\n      let count = 0\n      for (let i = -1; i <= 1; i++) {\n        for (let j = -1; j <= 1; j++) {\n          if (row + i < 0 || col + j < 0 || (i === 0 && j === 0)) continue\n          if (grid[row + i]?.[col + j] === true) {\n            count++\n          }\n        }\n      }\n\n      // 割り当て\n      let isAlive = false\n      if (grid[row][col] == false && count == 3) {\n        isAlive = true\n      } else if (grid[row][col] == true) {\n        if (count < 2 || 3 < count) {\n          isAlive = false\n        } else if (count === 2 || count === 3) {\n          isAlive = true\n        }\n      }\n      nextGrid[row][col] = isAlive\n    }\n  }\n  return nextGrid\n}\n"],"names":["renderGrid","grid","ROWS","COLS","ctx","RESOLUTION","row","col","cell","beginPath","rect","fillStyle","fill","stroke","canvas","document","querySelector","getContext","startButton","pauseButton","width","height","animationId","sound","Audio","Array","map","Math","floor","random","update","nextGrid","arr","count","i","j","isAlive","updateGrid","requestAnimationFrame","addEventListener","evt","getBoundingClientRect","pos","clientX","left","clientY","top","cloneNode","play","cancelAnimationFrame"],"sourceRoot":""}